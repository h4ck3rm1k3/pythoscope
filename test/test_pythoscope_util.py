import unittest


class TestCompact(unittest.TestCase):
    def test_compact(self):
        # self.assertEqual(expected, compact(lst))
        assert False  # TODO: implement your test here

class TestCounted(unittest.TestCase):
    def test_counted(self):
        # self.assertEqual(expected, counted(objects))
        assert False  # TODO: implement your test here

class TestCamelize(unittest.TestCase):
    def test_camelize(self):
        # self.assertEqual(expected, camelize(name))
        assert False  # TODO: implement your test here

class TestUnderscore(unittest.TestCase):
    def test_underscore(self):
        # self.assertEqual(expected, underscore(name))
        assert False  # TODO: implement your test here

class TestPluralize(unittest.TestCase):
    def test_pluralize(self):
        # self.assertEqual(expected, pluralize(word, count))
        assert False  # TODO: implement your test here

class TestString2id(unittest.TestCase):
    def test_string2id(self):
        # self.assertEqual(expected, string2id(string))
        assert False  # TODO: implement your test here

class TestString2filename(unittest.TestCase):
    def test_string2filename(self):
        # self.assertEqual(expected, string2filename(string))
        assert False  # TODO: implement your test here

class TestFileMode(unittest.TestCase):
    def test_file_mode(self):
        # self.assertEqual(expected, file_mode(base, binary))
        assert False  # TODO: implement your test here

class TestReadFileContents(unittest.TestCase):
    def test_read_file_contents(self):
        # self.assertEqual(expected, read_file_contents(filename, binary))
        assert False  # TODO: implement your test here

class TestWriteContentToFile(unittest.TestCase):
    def test_write_content_to_file(self):
        # self.assertEqual(expected, write_content_to_file(string, filename, binary))
        assert False  # TODO: implement your test here

class TestAllOfType(unittest.TestCase):
    def test_all_of_type(self):
        # self.assertEqual(expected, all_of_type(objects, type))
        assert False  # TODO: implement your test here

class TestMaxByNotZero(unittest.TestCase):
    def test_max_by_not_zero(self):
        # self.assertEqual(expected, max_by_not_zero(func, collection))
        assert False  # TODO: implement your test here

class TestGetNames(unittest.TestCase):
    def test_get_names(self):
        # self.assertEqual(expected, get_names(objects))
        assert False  # TODO: implement your test here

class TestMapValues(unittest.TestCase):
    def test_map_values(self):
        # self.assertEqual(expected, map_values(function, dictionary))
        assert False  # TODO: implement your test here

class TestEnsureDirectory(unittest.TestCase):
    def test_ensure_directory(self):
        # self.assertEqual(expected, ensure_directory(directory))
        assert False  # TODO: implement your test here

class TestGetLastModificationTime(unittest.TestCase):
    def test_get_last_modification_time(self):
        # self.assertEqual(expected, get_last_modification_time(path))
        assert False  # TODO: implement your test here

class TestStartsWithPath(unittest.TestCase):
    def test_starts_with_path(self):
        # self.assertEqual(expected, starts_with_path(path, prefix))
        assert False  # TODO: implement your test here

class TestExtractSubpath(unittest.TestCase):
    def test_extract_subpath(self):
        # self.assertEqual(expected, extract_subpath(path, prefix))
        assert False  # TODO: implement your test here

class TestDirectoriesUnder(unittest.TestCase):
    def test_directories_under(self):
        # self.assertEqual(expected, directories_under(path))
        assert False  # TODO: implement your test here

class TestFindfirst(unittest.TestCase):
    def test_findfirst(self):
        # self.assertEqual(expected, findfirst(pred, seq))
        assert False  # TODO: implement your test here

class TestFlatten(unittest.TestCase):
    def test_flatten(self):
        # self.assertEqual(expected, flatten(lst))
        assert False  # TODO: implement your test here

class TestUnion(unittest.TestCase):
    def test_union(self):
        # self.assertEqual(expected, union(*sets))
        assert False  # TODO: implement your test here

class TestKeyForValue(unittest.TestCase):
    def test_key_for_value(self):
        # self.assertEqual(expected, key_for_value(dictionary, value))
        assert False  # TODO: implement your test here

class TestGetGeneratorFromFrame(unittest.TestCase):
    def test_get_generator_from_frame(self):
        # self.assertEqual(expected, get_generator_from_frame(frame))
        assert False  # TODO: implement your test here

class TestIsGeneratorCode(unittest.TestCase):
    def test_is_generator_code(self):
        # self.assertEqual(expected, is_generator_code(code))
        assert False  # TODO: implement your test here

class TestGeneratorHasEnded(unittest.TestCase):
    def test_generator_has_ended(self):
        # self.assertEqual(expected, generator_has_ended(generator))
        assert False  # TODO: implement your test here

class TestIsMethodWrapper(unittest.TestCase):
    def test_is_method_wrapper(self):
        # self.assertEqual(expected, is_method_wrapper(obj))
        assert False  # TODO: implement your test here

class TestGetSelfFromMethod(unittest.TestCase):
    def test_get_self_from_method(self):
        # self.assertEqual(expected, get_self_from_method(method))
        assert False  # TODO: implement your test here

class TestCompileWithoutWarnings(unittest.TestCase):
    def test_compile_without_warnings(self):
        # self.assertEqual(expected, compile_without_warnings(stmt))
        assert False  # TODO: implement your test here

class TestCallersName(unittest.TestCase):
    def test_callers_name(self):
        # self.assertEqual(expected, callers_name())
        assert False  # TODO: implement your test here

class TestTypeNames(unittest.TestCase):
    def test_type_names(self):
        # self.assertEqual(expected, type_names(types))
        assert False  # TODO: implement your test here

class TestAssertArgumentType(unittest.TestCase):
    def test_assert_argument_type(self):
        # self.assertEqual(expected, assert_argument_type(obj, expected_type))
        assert False  # TODO: implement your test here

class TestQuotedBlock(unittest.TestCase):
    def test_quoted_block(self):
        # self.assertEqual(expected, quoted_block(text))
        assert False  # TODO: implement your test here

class TestClassOf(unittest.TestCase):
    def test_class_of(self):
        # self.assertEqual(expected, class_of(obj))
        assert False  # TODO: implement your test here

class TestClassName(unittest.TestCase):
    def test_class_name(self):
        # self.assertEqual(expected, class_name(obj))
        assert False  # TODO: implement your test here

class TestModuleName(unittest.TestCase):
    def test_module_name(self):
        # self.assertEqual(expected, module_name(obj))
        assert False  # TODO: implement your test here

class TestModulePathToName(unittest.TestCase):
    def test_module_path_to_name(self):
        # self.assertEqual(expected, module_path_to_name(module_path, newsep))
        assert False  # TODO: implement your test here

class TestLastTraceback(unittest.TestCase):
    def test_last_traceback(self):
        # self.assertEqual(expected, last_traceback())
        assert False  # TODO: implement your test here

class TestLastExceptionAsString(unittest.TestCase):
    def test_last_exception_as_string(self):
        # self.assertEqual(expected, last_exception_as_string())
        assert False  # TODO: implement your test here

class TestRegexpFlagsAsString(unittest.TestCase):
    def test_regexp_flags_as_string(self):
        # self.assertEqual(expected, regexp_flags_as_string(flags))
        assert False  # TODO: implement your test here

class TestLoadPickleFrom(unittest.TestCase):
    def test_load_pickle_from(self):
        # self.assertEqual(expected, load_pickle_from(path))
        assert False  # TODO: implement your test here

if __name__ == '__main__':
    unittest.main()
