import unittest


class TestExecution(unittest.TestCase):
    def test___init__(self):
        # execution = Execution(project)
        assert False  # TODO: implement your test here

    def test_create_call(self):
        # execution = Execution(project)
        # self.assertEqual(expected, execution.create_call(call_type, definition, callable, args, code, frame))
        assert False  # TODO: implement your test here

    def test_create_function_call(self):
        # execution = Execution(project)
        # self.assertEqual(expected, execution.create_function_call(name, args, code, frame))
        assert False  # TODO: implement your test here

    def test_create_method_call(self):
        # execution = Execution(project)
        # self.assertEqual(expected, execution.create_method_call(name, obj, args, code, frame))
        assert False  # TODO: implement your test here

    def test_create_serialized_object(self):
        # execution = Execution(project)
        # self.assertEqual(expected, execution.create_serialized_object(obj))
        assert False  # TODO: implement your test here

    def test_create_serialized_user_object(self):
        # execution = Execution(project)
        # self.assertEqual(expected, execution.create_serialized_user_object(obj))
        assert False  # TODO: implement your test here

    def test_create_side_effect(self):
        # execution = Execution(project)
        # self.assertEqual(expected, execution.create_side_effect(klass, *args))
        assert False  # TODO: implement your test here

    def test_destroy(self):
        # execution = Execution(project)
        # self.assertEqual(expected, execution.destroy())
        assert False  # TODO: implement your test here

    def test_destroy_references(self):
        # execution = Execution(project)
        # self.assertEqual(expected, execution.destroy_references())
        assert False  # TODO: implement your test here

    def test_finalize(self):
        # execution = Execution(project)
        # self.assertEqual(expected, execution.finalize())
        assert False  # TODO: implement your test here

    def test_iter_captured_generator_objects(self):
        # execution = Execution(project)
        # self.assertEqual(expected, execution.iter_captured_generator_objects())
        assert False  # TODO: implement your test here

    def test_remove_call_from_call_graph(self):
        # execution = Execution(project)
        # self.assertEqual(expected, execution.remove_call_from_call_graph(call_to_remove))
        assert False  # TODO: implement your test here

    def test_serialize(self):
        # execution = Execution(project)
        # self.assertEqual(expected, execution.serialize(obj))
        assert False  # TODO: implement your test here

    def test_serialize_call_arguments(self):
        # execution = Execution(project)
        # self.assertEqual(expected, execution.serialize_call_arguments(args))
        assert False  # TODO: implement your test here

    def test_try_serializing_as_user_object(self):
        # execution = Execution(project)
        # self.assertEqual(expected, execution.try_serializing_as_user_object(obj))
        assert False  # TODO: implement your test here

class TestObjectId(unittest.TestCase):
    def test_object_id(self):
        # self.assertEqual(expected, object_id(obj))
        assert False  # TODO: implement your test here

class TestSaveGeneratorInside(unittest.TestCase):
    def test_save_generator_inside(self):
        # self.assertEqual(expected, save_generator_inside(gobject, generator))
        assert False  # TODO: implement your test here

class TestIsExhausedGeneratorObject(unittest.TestCase):
    def test_is_exhaused_generator_object(self):
        # self.assertEqual(expected, is_exhaused_generator_object(gobject))
        assert False  # TODO: implement your test here

if __name__ == '__main__':
    unittest.main()
