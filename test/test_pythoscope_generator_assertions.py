import unittest


class TestTestTimelineForMethod(unittest.TestCase):
    def test_test_timeline_for_method(self):
        # self.assertEqual(expected, test_timeline_for_method(method))
        assert False  # TODO: implement your test here

class TestTestTimelineForFunction(unittest.TestCase):
    def test_test_timeline_for_function(self):
        # self.assertEqual(expected, test_timeline_for_function(function))
        assert False  # TODO: implement your test here

class TestCallWithArgs(unittest.TestCase):
    def test_call_with_args(self):
        # self.assertEqual(expected, call_with_args(callable, args))
        assert False  # TODO: implement your test here

class TestClassInitStub(unittest.TestCase):
    def test_class_init_stub(self):
        # self.assertEqual(expected, class_init_stub(klass))
        assert False  # TODO: implement your test here

class TestTestTimelineForUserObject(unittest.TestCase):
    def test_test_timeline_for_user_object(self):
        # self.assertEqual(expected, test_timeline_for_user_object(execution_events, user_object))
        assert False  # TODO: implement your test here

class TestLastCallActionTimestamp(unittest.TestCase):
    def test_last_call_action_timestamp(self):
        # self.assertEqual(expected, last_call_action_timestamp(call))
        assert False  # TODO: implement your test here

class TestGiveContextToMethodCalls(unittest.TestCase):
    def test_give_context_to_method_calls(self):
        # self.assertEqual(expected, give_context_to_method_calls(events, user_object))
        assert False  # TODO: implement your test here

class TestAddTestEventsForOutput(unittest.TestCase):
    def test_add_test_events_for_output(self):
        # self.assertEqual(expected, add_test_events_for_output(events, execution_events, call))
        assert False  # TODO: implement your test here

class TestAddTestEventsForSideEffects(unittest.TestCase):
    def test_add_test_events_for_side_effects(self):
        # self.assertEqual(expected, add_test_events_for_side_effects(events, side_effects))
        assert False  # TODO: implement your test here

class TestSideEffectsOfCall(unittest.TestCase):
    def test_side_effects_of_call(self):
        # self.assertEqual(expected, side_effects_of_call(call))
        assert False  # TODO: implement your test here

class TestTestTimelineForCall(unittest.TestCase):
    def test_test_timeline_for_call(self):
        # self.assertEqual(expected, test_timeline_for_call(execution_events, call))
        assert False  # TODO: implement your test here

class TestEventCopy(unittest.TestCase):
    def test_event_copy(self):
        # self.assertEqual(expected, event_copy(event))
        assert False  # TODO: implement your test here

class TestReplace(unittest.TestCase):
    def test_replace(self):
        # self.assertEqual(expected, replace(alist, old_element, new_element))
        assert False  # TODO: implement your test here

class TestCopySideEffects(unittest.TestCase):
    def test_copy_side_effects(self):
        # self.assertEqual(expected, copy_side_effects(side_effects, old_obj, new_obj))
        assert False  # TODO: implement your test here

class TestExpandIntoTimeline(unittest.TestCase):
    def test_expand_into_timeline(self):
        # self.assertEqual(expected, expand_into_timeline(*events))
        assert False  # TODO: implement your test here

class TestEnumerateEvents(unittest.TestCase):
    def test_enumerate_events(self):
        # self.assertEqual(expected, enumerate_events(objs))
        assert False  # TODO: implement your test here

class TestSideEffectsBeforeAndAffectedObjects(unittest.TestCase):
    def test_side_effects_before_and_affected_objects(self):
        # self.assertEqual(expected, side_effects_before_and_affected_objects(call))
        assert False  # TODO: implement your test here

class TestRemoveDuplicatesAndBareMethodContexts(unittest.TestCase):
    def test_remove_duplicates_and_bare_method_contexts(self):
        # self.assertEqual(expected, remove_duplicates_and_bare_method_contexts(events))
        assert False  # TODO: implement your test here

class TestIncludeRequirements(unittest.TestCase):
    def test_include_requirements(self):
        # self.assertEqual(expected, include_requirements(test_events, execution_events))
        assert False  # TODO: implement your test here

class TestUsedLaterThan(unittest.TestCase):
    def test_used_later_than(self):
        # self.assertEqual(expected, used_later_than(event, timeline, timestamp))
        assert False  # TODO: implement your test here

class TestFixTestsUsingCallOutputs(unittest.TestCase):
    def test_fix_tests_using_call_outputs(self):
        # self.assertEqual(expected, fix_tests_using_call_outputs(timeline))
        assert False  # TODO: implement your test here

class TestExplicitCalls(unittest.TestCase):
    def test_explicit_calls(self):
        # self.assertEqual(expected, explicit_calls(event))
        assert False  # TODO: implement your test here

class TestObjectsRequiredFor(unittest.TestCase):
    def test_objects_required_for(self):
        # self.assertEqual(expected, objects_required_for(test_event, timestamp, execution_events))
        assert False  # TODO: implement your test here

class TestCopyEventsOver(unittest.TestCase):
    def test_copy_events_over(self):
        # self.assertEqual(expected, copy_events_over(objects, timestamp, execution_events))
        assert False  # TODO: implement your test here

class TestNewOnly(unittest.TestCase):
    def test_new_only(self):
        # self.assertEqual(expected, new_only(affected, so_far))
        assert False  # TODO: implement your test here

class TestSideEffectsThatAffectObject(unittest.TestCase):
    def test_side_effects_that_affect_object(self):
        # self.assertEqual(expected, side_effects_that_affect_object(events, obj))
        assert False  # TODO: implement your test here

if __name__ == '__main__':
    unittest.main()
